<html>

    <head>
        <title>ICG WebGL &mdash; HW1</title>
        <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

        <script type="text/javascript" src="./js/glMatrix-0.9.5.min.js"></script>
        <script type="text/javascript" src="./js/webgl-utils.js"></script>

        <!-- 
TODO HERE: 
modify fragment shader or write another one
to implement flat, gouraud and phong shading
-->     <script id="flatFragmentShader" type="fragment">
        #extension GL_OES_standard_derivatives : enable

        precision mediump float;

        varying vec4 fragcolor;

        void main(void) {
        gl_FragColor = fragcolor;
        }
        </script>

        <script id="gouraudFragmentShader" type="fragment">
        #extension GL_OES_standard_derivatives : enable

        precision mediump float;

        varying vec4 fragcolor;

        void main(void) {
        gl_FragColor = fragcolor;
        }
        </script>

        <script id="phongFragmentShader" type="fragment">
        precision mediump float;

        varying vec3 vPosition;
        varying vec3 vNormal;
        varying vec3 vColor;

        uniform float Ka;
        uniform vec3 lightLoc[2];
        uniform vec4 clipPlane;

        void main(void) {
            // clipping
            if (dot(vec4(vPosition, 1.0), clipPlane) < 0.0) {
                discard;
            }

            vec3 lightColor[2];
            lightColor[0] = vec3(0.0, 0.3, 0.8);   // deep blue
            lightColor[1] = vec3(1.0, 0.75, 0.2);  // amber
            
            vec3 N = normalize(vNormal);
        vec3 V = normalize(-vPosition);
            
            float ka = Ka;
            float kd = 0.6;
            float ks = 0.3;
            float shininess = 16.0;
            
            vec3 ambient = ka * vColor;
            vec3 totalDiffuse = vec3(0.0);
            vec3 totalSpecular = vec3(0.0);
        
            for(int i = 0; i < 2; ++i) {
                vec3 L = normalize(lightLoc[i] - vPosition);
                vec3 H = normalize(L + V);

                float diff = max(dot(N, L), 0.0);
                totalDiffuse += kd * diff * lightColor[i];
                
                float spec = pow(max(dot(N, H), 0.0), shininess);
                totalSpecular += ks * spec * lightColor[i];
            }
            
            vec3 finalColor = clamp(ambient + totalDiffuse + totalSpecular, 0.0, 1.0);
            gl_FragColor = vec4(finalColor, 1.0);
        }
        </script>

        <!-- 
TODO HERE:
modify vertex shader or write another one
to implement flat, gouraud and phong shading

NOTE:
if you want to write bonus part (texture mapping),
only Teapot.json has extra attribute "vertexTextureCoords"
which is used for texture mappping.
-->
        <script id="flatVertexShader" type="vertex">
        attribute vec3 aVertexPosition;
        attribute vec3 aFrontColor;
        attribute vec3 aVertexNormal;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;

        // Ambient light coef.
        uniform float Ka;
        // light locations (x,y,z)
        uniform vec3 lightLoc[2];

        varying vec4 fragcolor;

        void main(void) {
            vec3 lightColor[2];
            lightColor[0] = vec3(0.0, 0.3, 0.8);   // deep blue
            lightColor[1] = vec3(1.0, 0.75, 0.2);  // amber

            // Transform VertexPosition and VertexNormal to world coordinate system
            vec3 mvVertex = (uMVMatrix * vec4(aVertexPosition, 1.0)).xyz;
            mat3 normalMVMatrix = mat3(uMVMatrix);
            vec3 mvNormal = normalMVMatrix * aVertexNormal;

            // V, N
            vec3 V = -normalize(mvVertex);
            vec3 N = normalize(mvNormal);
            
            float ka = Ka;
            float kd = 0.6;
            float ks = 0.3;
            float shininess = 16.0;

            vec3 ambient = ka * aFrontColor;
            vec3 totalDiffuse = vec3(0.0);
            vec3 totalSpecular = vec3(0.0);

            for(int i = 0; i < 2; ++i) {
                vec3 L = normalize(lightLoc[i] - mvVertex);
                vec3 H = normalize(L + V);

                float diff = max(dot(N, L), 0.0);
                totalDiffuse += kd * diff * lightColor[i];
                
                float spec = pow(max(dot(N, H), 0.0), shininess);
                totalSpecular += ks * spec * lightColor[i];
            }

            vec3 finalColor = clamp(ambient + totalDiffuse + totalSpecular, 0.0, 1.0);
            fragcolor = vec4(finalColor, 1.0);
            gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        }
        </script>

        <script id="gouraudVertexShader" type="vertex">
        attribute vec3 aVertexPosition;
        attribute vec3 aFrontColor;
        attribute vec3 aVertexNormal;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;

        // Ambient light coef.
        uniform float Ka;
        // light locations (x,y,z)
        uniform vec3 lightLoc[2];

        varying vec4 fragcolor;

        void main(void) {
            vec3 lightColor[2];
            lightColor[0] = vec3(0.0, 0.3, 0.8);   // deep blue
            lightColor[1] = vec3(1.0, 0.75, 0.2);  // amber

            // Transform VertexPosition and VertexNormal to world coordinate system
            vec3 mvVertex = (uMVMatrix * vec4(aVertexPosition, 1.0)).xyz;
            mat3 normalMVMatrix = mat3(uMVMatrix);
            vec3 mvNormal = normalMVMatrix * aVertexNormal;

            // V, N
            vec3 V = -normalize(mvVertex);
            vec3 N = normalize(mvNormal);
            
            float ka = Ka;
            float kd = 0.6;
            float ks = 0.3;
            float shininess = 16.0;

            vec3 ambient = ka * aFrontColor;
            vec3 totalDiffuse = vec3(0.0);
            vec3 totalSpecular = vec3(0.0);

            for(int i = 0; i < 2; ++i) {
                vec3 L = normalize(lightLoc[i] - mvVertex);
                vec3 H = normalize(L + V);

                float diff = max(dot(N, L), 0.0);
                totalDiffuse += kd * diff * lightColor[i];
                
                float spec = pow(max(dot(N, H), 0.0), shininess);
                totalSpecular += ks * spec * lightColor[i];
            }

            vec3 finalColor = clamp(ambient + totalDiffuse + totalSpecular, 0.0, 1.0);
            fragcolor = vec4(finalColor, 1.0);
            gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        }
        </script>

        <script id="phongVertexShader" type="vertex">
        attribute vec3 aVertexPosition;
        attribute vec3 aFrontColor;
        attribute vec3 aVertexNormal;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;

        varying vec3 vPosition;
        varying vec3 vNormal;
        varying vec3 vColor;

        void main(void) {
            vec4 mvPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
            vPosition = mvPosition.xyz;
            mat3 normalMatrix = mat3(uMVMatrix);
            vNormal = normalize(normalMatrix * aVertexNormal);
            vColor = aFrontColor;
            gl_Position = uPMatrix * mvPosition;
        }
        </script>

        <script type="text/javascript">
        // common variables
        var gl;
        var flatShaderProgram;
        var gouraudShaderProgram;
        var phongShaderProgram;

        var mvMatrix1 = mat4.create();
        var mvMatrix2 = mat4.create();
        var mvMatrix3 = mat4.create();
        var pMatrix1  = mat4.create();
        var pMatrix2  = mat4.create();
        var pMatrix3  = mat4.create();

        /*
         * object buffers
         */
        // teapot
        var teapotVertexPositionBuffer;
        var teapotVertexNormalBuffer;
        var teapotVertexFrontColorBuffer;

        var flatTeapotVertexPositionBuffer;
        var flatTeapotVertexNormalBuffer;
        var flatTeapotVertexFrontColorBuffer;

        // tomcat
        var tomcatVertexPositionBuffer;
        var tomcatVertexNormalBuffer;
        var tomcatVertexFrontColorBuffer;

        var flatTomcatVertexPositionBuffer;
        var flatTomcatVertexNormalBuffer;
        var flatTomcatVertexFrontColorBuffer;

        // mig27
        var mig27VertexPositionBuffer;
        var mig27VertexNormalBuffer;
        var mig27VertexFrontColorBuffer;

        var flatMig27VertexPositionBuffer;
        var flatMig27VertexNormalBuffer;
        var flatMig27VertexFrontColorBuffer;

        var teapot1Angle = 180;
        var teapot2Angle = 180;
        var teapot3Angle = 180;
        var lastTime    = 0;

        var ka = 0.1;
        // var light_locations = new Float32Array([30., 20., -25.]);
        var light_num = 2;
        // var light_locations = Array.from({ length: light_num }, () => new Float32Array([30., 20., -25.]));
        var light_locations = [
            new Float32Array([30., 20., -25.]),
            new Float32Array([-100., -100., -100.])
        ];

        var clipPlanes = [
            {a: 0.0, b: 0.0, c: 0.0, d: 0.0},
            {a: 0.0, b: 0.0, c: 0.0, d: 0.0},
            {a: 0.0, b: 0.0, c: 0.0, d: 0.0}
        ];

        //*************************************************
        // Initialization functions
        //*************************************************
        function initGL(canvas) {
            try {
                gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
                gl.viewportWidth  = canvas.width;
                gl.viewportHeight = canvas.height;
            } 
            catch (e) {
            }

            if (!gl) {
                alert("Could not initialise WebGL");
            }
        }

        function getShader(gl, id) {
            var shaderScript = document.getElementById(id);
            if (!shaderScript) {
                return null;
            }

            var shaderSource = "";
            var k = shaderScript.firstChild;
            while (k) {
                if (k.nodeType == 3) {
                    shaderSource += k.textContent;
                }

                k = k.nextSibling;
            }

            var shader;
            if (shaderScript.type == "fragment") {
                shader = gl.createShader(gl.FRAGMENT_SHADER);
            } 
            else if (shaderScript.type == "vertex") {
                shader = gl.createShader(gl.VERTEX_SHADER);
            } 
            else {
                return null;
            }

            gl.shaderSource(shader, shaderSource);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert(gl.getShaderInfoLog(shader));
                return null;
            }

            return shader;
        }

        function initShaders() {
            // Create flat shader program
            var flatFragmentShader = getShader(gl, "flatFragmentShader");
            var flatVertexShader   = getShader(gl, "flatVertexShader");
            flatShaderProgram = createShaderProgram(flatVertexShader, flatFragmentShader);
            console.log("flat shader program initialized");

            var gouraudFragmentShader = getShader(gl, "gouraudFragmentShader");
            var gouraudVertexShader   = getShader(gl, "gouraudVertexShader");
            gouraudShaderProgram = createShaderProgram(gouraudVertexShader, gouraudFragmentShader);
            console.log("gouraud shader program initialized");

            var phongFragmentShader = getShader(gl, "phongFragmentShader");
            var phongVertexShader = getShader(gl, "phongVertexShader");
            phongShaderProgram = createShaderProgram(phongVertexShader, phongFragmentShader);
            console.log("phong shader program initialized");
        }

        function createShaderProgram(customVS, customFS) {
            var program = gl.createProgram();
            gl.attachShader(program, customVS);
            gl.attachShader(program, customFS);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }

            gl.useProgram(program);

            program.vertexPositionAttribute = gl.getAttribLocation(program, "aVertexPosition");
            gl.enableVertexAttribArray(program.vertexPositionAttribute);
            program.vertexFrontColorAttribute = gl.getAttribLocation(program, "aFrontColor");
            gl.enableVertexAttribArray(program.vertexFrontColorAttribute);
            program.vertexNormalAttribute = gl.getAttribLocation(program, "aVertexNormal");
            gl.enableVertexAttribArray(program.vertexNormalAttribute);

            var flatLightLocs = new Float32Array(light_num * 3);
            flatLightLocs.set(light_locations[0], 0);
            flatLightLocs.set(light_locations[1], 3)

            gl.uniform1f(gl.getUniformLocation(program, "Ka"), ka);
            gl.uniform3fv(gl.getUniformLocation(program, "lightLoc"), flatLightLocs);

            program.pMatrixUniform  = gl.getUniformLocation(program, "uPMatrix");
            program.mvMatrixUniform = gl.getUniformLocation(program, "uMVMatrix");
            program.clipPlaneUniform = gl.getUniformLocation(program, "clipPlane");

            return program;
        }

        function setMatrixUniforms(program, mvMatrix, pMatrix) {
            gl.uniformMatrix4fv(program.pMatrixUniform, false, pMatrix);
            gl.uniformMatrix4fv(program.mvMatrixUniform, false, mvMatrix);
        }

        function degToRad(degrees) {
            return degrees * Math.PI / 180;
        }

        function convertToFlatShading(teapotData) {
            const positions = teapotData.vertexPositions;
            const colors = teapotData.vertexFrontcolors;
            const flatPositions = [];
            const flatNormals = [];
            const flatColors = [];

            for (let i = 0; i < positions.length; i += 9) {
                // 一組 triangle：3 個頂點，每個 3 維
                const v0 = positions.slice(i, i + 3);
                const v1 = positions.slice(i + 3, i + 6);
                const v2 = positions.slice(i + 6, i + 9);

                const normal = computeFaceNormal(v0, v1, v2);

                // 使用第一個頂點的顏色當整個面的顏色
                const c0 = colors.slice(i, i + 3);

                [v0, v1, v2].forEach((v) => {
                    flatPositions.push(...v);
                    flatNormals.push(...normal);
                    flatColors.push(...c0);
                });
            }

            return {
                vertexPositions: flatPositions,
                vertexNormals: flatNormals,
                vertexFrontcolors: flatColors
            };
        }

        function computeFaceNormal(v0, v1, v2) {
            const U = [
                v1[0] - v0[0],
                v1[1] - v0[1],
                v1[2] - v0[2]
            ];
            const V = [
                v2[0] - v0[0],
                v2[1] - v0[1],
                v2[2] - v0[2]
            ];
            const N = [
                U[1] * V[2] - U[2] * V[1],
                U[2] * V[0] - U[0] * V[2],
                U[0] * V[1] - U[1] * V[0]
            ];
            const length = Math.sqrt(N[0] * N[0] + N[1] * N[1] + N[2] * N[2]);
            return [N[0] / length, N[1] / length, N[2] / length];
        }

        function handleLoadedTeapot(teapotData) {
            var vertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(teapotData.vertexPositions), gl.STATIC_DRAW);
            vertexPositionBuffer.itemSize = 3;
            vertexPositionBuffer.numItems = teapotData.vertexPositions.length / 3;

            var vertexNormalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(teapotData.vertexNormals), gl.STATIC_DRAW);
            vertexNormalBuffer.itemSize = 3;
            vertexNormalBuffer.numItems = teapotData.vertexNormals.length / 3;

            var vertexFrontColorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexFrontColorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(teapotData.vertexFrontcolors), gl.STATIC_DRAW);
            vertexFrontColorBuffer.itemSize = 3;
            vertexFrontColorBuffer.numItems = teapotData.vertexFrontcolors.length / 3;

            return {
                positionBuffer: vertexPositionBuffer,
                normalBuffer: vertexNormalBuffer,
                colorBuffer: vertexFrontColorBuffer
            };
        }

        function loadObjects() {
            // load teapot
            var teapotRequest = new XMLHttpRequest();
            teapotRequest.open("GET", "./model/Teapot.json");
            teapotRequest.onreadystatechange = function () {
                if (teapotRequest.readyState == 4) {
                    let teapotData = JSON.parse(teapotRequest.responseText);
                    let buffers = handleLoadedTeapot(teapotData);
                    teapotVertexPositionBuffer = buffers.positionBuffer;
                    teapotVertexNormalBuffer = buffers.normalBuffer;
                    teapotVertexFrontColorBuffer = buffers.colorBuffer;

                    let flatTeapotData = convertToFlatShading(teapotData);
                    let flatBuffers = handleLoadedTeapot(flatTeapotData);
                    flatTeapotVertexPositionBuffer = flatBuffers.positionBuffer;
                    flatTeapotVertexNormalBuffer = flatBuffers.normalBuffer;
                    flatTeapotVertexFrontColorBuffer = flatBuffers.colorBuffer;
                }
            }
            teapotRequest.send();
            // load tomcat
            var tomcatRequest = new XMLHttpRequest();
            tomcatRequest.open("GET", "./model/Tomcat.json");
            tomcatRequest.onreadystatechange = function () {
                if (tomcatRequest.readyState == 4) {
                    let tomcatData = JSON.parse(tomcatRequest.responseText);
                    let buffers = handleLoadedTeapot(tomcatData);
                    tomcatVertexPositionBuffer = buffers.positionBuffer;
                    tomcatVertexNormalBuffer = buffers.normalBuffer;
                    tomcatVertexFrontColorBuffer = buffers.colorBuffer;

                    let flatTomcatData = convertToFlatShading(tomcatData);
                    let flatBuffers = handleLoadedTeapot(flatTomcatData);
                    flatTomcatVertexPositionBuffer = flatBuffers.positionBuffer;
                    flatTomcatVertexNormalBuffer = flatBuffers.normalBuffer;
                    flatTomcatVertexFrontColorBuffer = flatBuffers.colorBuffer;
                }
            }
            tomcatRequest.send();
            // load Mig27
            var mig27Request = new XMLHttpRequest();
            mig27Request.open("GET", "./model/Mig27.json");
            mig27Request.onreadystatechange = function () {
                if (mig27Request.readyState == 4) {
                    let mig27Data = JSON.parse(mig27Request.responseText);
                    let buffers = handleLoadedTeapot(mig27Data);
                    mig27VertexPositionBuffer = buffers.positionBuffer;
                    mig27VertexNormalBuffer = buffers.normalBuffer;
                    mig27VertexFrontColorBuffer = buffers.colorBuffer;

                    let flatMig27Data = convertToFlatShading(mig27Data);
                    let flatBuffers = handleLoadedTeapot(flatMig27Data);
                    flatMig27VertexPositionBuffer = flatBuffers.positionBuffer;
                    flatMig27VertexNormalBuffer = flatBuffers.normalBuffer;
                    flatMig27VertexFrontColorBuffer = flatBuffers.colorBuffer;
                }
            }
            mig27Request.send();
        }

        //*************************************************
        // Rendering functions
        //*************************************************
        /*
        TODO HERE:
        add two or more objects showing on the canvas
        (it needs at least three objects showing at the same time)
    */

        function drawAllScene() {
            console.log("drawAllScene");
            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
            gl.clearColor(ka, ka, ka, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            drawScene(mvMatrix1, pMatrix1, -20, 0, 0, teapot1Angle, flatShaderProgram, flatTeapotVertexPositionBuffer, flatTeapotVertexNormalBuffer, flatTeapotVertexFrontColorBuffer, 1);
            drawScene(mvMatrix2, pMatrix2, 0, 0, 0, teapot2Angle, gouraudShaderProgram, tomcatVertexPositionBuffer, tomcatVertexNormalBuffer, tomcatVertexFrontColorBuffer, 2);
            drawScene(mvMatrix3, pMatrix3, 20, 0, 0, teapot3Angle, phongShaderProgram, mig27VertexPositionBuffer, mig27VertexNormalBuffer, mig27VertexFrontColorBuffer, 3);
        }

        function drawScene(mvMatrix, pMatrix, translate_x, translate_y, translate_z, angle, program, vertexPositionBuffer, vertexNormalBuffer, vertexFrontColorBuffer, index) {
gl.useProgram(program);
            if (vertexPositionBuffer   == null || 
                vertexNormalBuffer     == null || 
                vertexFrontColorBuffer == null) {
                return;
            }

            // Setup Projection Matrix
            mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

            // Setup Model-View Matrix
            mat4.identity(mvMatrix);
             
            // Translate
            mat4.translate(mvMatrix, [translate_x, translate_y, translate_z]);
            if (index == 1) {
                mat4.translate(mvMatrix, update_trans(1));
            } else if (index == 2) {
                mat4.translate(mvMatrix, update_trans(2));
            } else if (index == 3) {
                mat4.translate(mvMatrix, update_trans(3));
            }

            // Rotate
            var rotateVec_init = [0,0,0];
            mat4.rotate(mvMatrix, degToRad(rotateVec_init[0]), [1, 0, 0]);
            mat4.rotate(mvMatrix, degToRad(rotateVec_init[1]), [0, 1, 0]);
            mat4.rotate(mvMatrix, degToRad(rotateVec_init[2]), [0, 0, 1]);

            var rotateVec;
            if (index == 1) {
                rotateVec = update_rotate(1);
            } else if (index == 2) {
                rotateVec = update_rotate(2);
            } else if (index == 3) {
                rotateVec = update_rotate(3);
            }
            mat4.rotate(mvMatrix, degToRad(rotateVec[0]), [1, 0, 0]);
            mat4.rotate(mvMatrix, degToRad(rotateVec[1] + angle), [0, 1, 0]);
            mat4.rotate(mvMatrix, degToRad(rotateVec[2]), [0, 0, 1]);

            // Shear
            var shearVec = update_shear(index);
            var shearMatrix = mat4.create();
            shearMatrix[0] = 1.0;
            shearMatrix[4] = shearVec[0];
            shearMatrix[8] = shearVec[1];
            shearMatrix[12] = 0.0;
            shearMatrix[1] = 0.0;
            shearMatrix[5] = 1.0;
            shearMatrix[9] = shearVec[2];
            shearMatrix[13] = 0.0;
            shearMatrix[2] = 0.0;
            shearMatrix[6] = 0.0;
            shearMatrix[10] = 1.0;
            shearMatrix[14] = 0.0;
            shearMatrix[3] = 0.0;
            shearMatrix[7] = 0.0;
            shearMatrix[11] = 0.0;
            shearMatrix[15] = 1.0;
            mat4.multiply(mvMatrix, shearMatrix);

            // Scale
            var scaleVec;
            if (index == 1) {
                scaleVec = update_scale(1);
            } else if (index == 2) {
                scaleVec = update_scale(2);
            } else if (index == 3) {
                scaleVec = update_scale(3);
            }
            mat4.scale(mvMatrix, [scaleVec[0], scaleVec[1], scaleVec[2]]);

            // Clip plane
            var clipPlane = clipPlanes[index - 1];
            gl.uniform4f(program.clipPlaneUniform,
                clipPlane.a,
                clipPlane.b,
                clipPlane.c,
                clipPlane.d); // 0.0, 0.0, 1.0, 0.0 (z = 0 plane) or other values

            setMatrixUniforms(program, mvMatrix, pMatrix);

            // Setup teapot position data
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
            gl.vertexAttribPointer(program.vertexPositionAttribute, 
                vertexPositionBuffer.itemSize, 
                gl.FLOAT, 
                false, 
                0, 
                0);

            // Setup teapot front color data
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexFrontColorBuffer);
            gl.vertexAttribPointer(program.vertexFrontColorAttribute, 
                vertexFrontColorBuffer.itemSize, 
                gl.FLOAT, 
                false, 
                0, 
                0);

            // Setup teapot normal data
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);
            gl.vertexAttribPointer(program.vertexNormalAttribute, 
                vertexNormalBuffer.itemSize, 
                gl.FLOAT, 
                false, 
                0, 
                0);

            // Setup ambient light and light position
            gl.uniform1f(gl.getUniformLocation(program, "Ka"), ka);

            var flatLightLocs = new Float32Array(light_num * 3);
            flatLightLocs.set(light_locations[0], 0);
            flatLightLocs.set(light_locations[1], 3)
            gl.uniform3fv(gl.getUniformLocation(program, "lightLoc"), flatLightLocs);

            gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems);
        }

        function animate() {
            var timeNow = new Date().getTime();
            if (lastTime != 0) {
                var elapsed = timeNow - lastTime;
                teapot1Angle += 0.03 * elapsed;
                teapot2Angle += 0.03 * elapsed;
                teapot3Angle += 0.03 * elapsed;
            }

            lastTime = timeNow;
        }

        function tick() {
            requestAnimFrame(tick);
            drawAllScene();
            animate();
        }

        function webGLStart() {
            var canvas = document.getElementById("ICG-canvas");
            initGL(canvas);
            initShaders();
            loadObjects();

            gl.clearColor(ka, ka, ka, 1.0);
            gl.enable(gl.DEPTH_TEST);

            tick();
        }


        //*************************************************
        // Parsing parameters
        //*************************************************
        function update_ambient_light(){
            ka = document.getElementById("am_ka").value;
        }

        function update_light_location(i){
            if (i == 0) {
                light_locations[i][0] = parseFloat(document.getElementById("llocX0").value);
                light_locations[i][1] = parseFloat(document.getElementById("llocY0").value);
                light_locations[i][2] = parseFloat(document.getElementById("llocZ0").value);
            } else if (i == 1) {
                light_locations[i][0] = parseFloat(document.getElementById("llocX1").value);
                light_locations[i][1] = parseFloat(document.getElementById("llocY1").value);
                light_locations[i][2] = parseFloat(document.getElementById("llocZ1").value);
            }
        }

        function update_trans(index){
            var tx;
            var ty;
            var tz;
            if (index == 1) {
                tx = document.getElementById("transX1").value;
                ty = document.getElementById("transY1").value;
                tz = document.getElementById("transZ1").value;
            }
            else if (index == 2) {
                tx = document.getElementById("transX2").value;
                ty = document.getElementById("transY2").value;
                tz = document.getElementById("transZ2").value;
            }
            else if (index == 3) {
                tx = document.getElementById("transX3").value;
                ty = document.getElementById("transY3").value;
                tz = document.getElementById("transZ3").value;
            }
            return vec3.create([tx, ty, tz]);
        }

        function update_rotate(index){
            var rx;
            var ry;
            var rz;
            if (index == 1) {
                rx = document.getElementById("rotateX1").value;
                ry = document.getElementById("rotateY1").value;
                rz = document.getElementById("rotateZ1").value;
            }
            else if (index == 2) {
                rx = document.getElementById("rotateX2").value;
                ry = document.getElementById("rotateY2").value;
                rz = document.getElementById("rotateZ2").value;
            }
            else if (index == 3) {
                rx = document.getElementById("rotateX3").value;
                ry = document.getElementById("rotateY3").value;
                rz = document.getElementById("rotateZ3").value;
            }
            return vec3.create([rx, ry, rz]);
        }

        function update_shear(index) {
            var xy, xz, yz;
            if (index == 1) {
                xy = document.getElementById("shearXY1").value;
                xz = document.getElementById("shearXZ1").value;
                yz = document.getElementById("shearYZ1").value;
            }
            else if (index == 2) {
                xy = document.getElementById("shearXY2").value;
                xz = document.getElementById("shearXZ2").value;
                yz = document.getElementById("shearYZ2").value;
            }
            else if (index == 3) {
                xy = document.getElementById("shearXY3").value;
                xz = document.getElementById("shearXZ3").value;
                yz = document.getElementById("shearYZ3").value;
            }
            return vec3.create([xy, xz, yz]);
        }

        function updateClipPlane(index) {
            var i = index - 1;
            clipPlanes[i].a = parseFloat(document.getElementById("clip" + index + "A").value);
            clipPlanes[i].b = parseFloat(document.getElementById("clip" + index + "B").value);
            clipPlanes[i].c = parseFloat(document.getElementById("clip" + index + "C").value);
            clipPlanes[i].d = parseFloat(document.getElementById("clip" + index + "D").value);
        }
        
        function update_scale(index) {
            var s;
            if (index == 1) {
                s = document.getElementById("scale1").value;
            }
            else if (index == 2) {
                s = document.getElementById("scale2").value;
            }
            else if (index == 3) {
                s = document.getElementById("scale3").value;
            }
            return vec3.create([s, s, s]);
        }
        </script>
    </head>

    <body onload="webGLStart();">
        <p style="position: absolute; right: 2%; top:6%; ">
            <canvas id="ICG-canvas" style="border: none;" width="1060" height="590" ></canvas>
        </p>

        <p style="position: absolute; left: 1%; top: 1%; max-width: 30%; min-width: 30%; ">

        <p>
            <label for="shading">CG HW1</label>
        </p>

        <br/>
        <span>Ambient Light</span>
        <table>
            <tr>
                <td>Ka: <input style="max-width: 70%; vertical-align: middle;" id="am_ka" type="range" autocomplete="off" value="0.1" max="1." min="0." step="0.05" oninput="update_ambient_light()"></td>
            </tr>
        </table>
        <br/>
        <span>Light 0</span>
        <table>
            <tr>
                <td>X: <input style="max-width: 70%; vertical-align: middle;" id="llocX0" type="range" autocomplete="off" value="40." max="40." min="-40." oninput="update_light_location(0)"></td>
                <td>Y: <input style="max-width: 70%; vertical-align: middle;" id="llocY0" type="range" autocomplete="off" value="40." max="40." min="-40." oninput="update_light_location(0)"></td>
                <td>Z: <input style="max-width: 70%; vertical-align: middle;" id="llocZ0" type="range" autocomplete="off" value="0." max="0." min="-75." oninput="update_light_location(0)"></td>
            </tr>
        </table>
        <span>Light 1</span>
        <table>
            <tr>
                <td>X: <input style="max-width: 70%; vertical-align: middle;" id="llocX1" type="range" autocomplete="off" value="-40." max="40." min="-40." oninput="update_light_location(1)"></td>
                <td>Y: <input style="max-width: 70%; vertical-align: middle;" id="llocY1" type="range" autocomplete="off" value="-40." max="40." min="-40." oninput="update_light_location(1)"></td>
                <td>Z: <input style="max-width: 70%; vertical-align: middle;" id="llocZ1" type="range" autocomplete="off" value="-75." max="0." min="-75." oninput="update_light_location(1)"></td>
            </tr>
        </table>
        <br/>
        <br/>

        <span>Object1 (Left)</span>
        <table>
            <tr>
                <th></th>
                <th>X axis</th>
                <th>Y axis</th>
                <th>Z axis</th>
            </tr>
            <tr>
                <td>Trans. 1</td>
                <td><input id="transX1" type="range" autocomplete="off" value="0." max="50." min="-10." oninput="update_trans(1)"></td>
                <td><input id="transY1" type="range" autocomplete="off" value="0." max="15." min="-15." oninput="update_trans(1)"></td>
                <td><input id="transZ1" type="range" autocomplete="off" value="-50." max="-40." min="-100." oninput="update_trans(1)"></td>
            </tr>
            <tr>
                <td>Rotate 1</td>
                <td><input id="rotateX1" type="range" autocomplete="off" value="0." max="180." min="-180." oninput="update_rotate(1)"></td>
                <td><input id="rotateY1" type="range" autocomplete="off" value="0." max="180." min="-180." oninput="update_rotate(1)"></td>
                <td><input id="rotateZ1" type="range" autocomplete="off" value="0." max="180." min="-180." oninput="update_rotate(1)"></td>
            </tr>
            <tr>
                <th></th>
                <th>XY plane</th>
                <th>XZ plane</th>
                <th>YZ plane</th>
            </tr>
            <tr>
                <td>Shear 1</td>
                <td><input id="shearXY1" type="range" autocomplete="off" value="0" max="1" min="-1" step="0.1" oninput="update_shear(1)"></td>
                <td><input id="shearXZ1" type="range" autocomplete="off" value="0" max="1" min="-1" step="0.1" oninput="update_shear(1)"></td>
                <td><input id="shearYZ1" type="range" autocomplete="off" value="0" max="1" min="-1" step="0.1" oninput="update_shear(1)"></td>
            </tr>
            <tr>
                <td>Scale 1</td>
                <td><input id="scale1" type="range" autocomplete="off" value="0.5" max="2.0" min="0.1" step="0.1" oninput="update_scale(1)"></td>
            </tr>
        </table>

        <br/>
        <br/>

        <span>Object2 (Mid)</span>
        <table>
            <tr>
                <th></th>
                <th>X axis</th>
                <th>Y axis</th>
                <th>Z axis</th>
            </tr>
            <tr>
                <td>Trans. 2</td>
                <td><input id="transX2" type="range" autocomplete="off" value="0." max="30." min="-30." oninput="update_trans(2)"></td>
                <td><input id="transY2" type="range" autocomplete="off" value="0." max="15." min="-15." oninput="update_trans(2)"></td>
                <td><input id="transZ2" type="range" autocomplete="off" value="-50." max="-40." min="-100." oninput="update_trans(2)"></td>
            </tr>
            <tr>
                <td>Rotate 2</td>
                <td><input id="rotateX2" type="range" autocomplete="off" value="0." max="180." min="-180." oninput="update_rotate(2)"></td>
                <td><input id="rotateY2" type="range" autocomplete="off" value="0." max="180." min="-180." oninput="update_rotate(2)"></td>
                <td><input id="rotateZ2" type="range" autocomplete="off" value="0." max="180." min="-180." oninput="update_rotate(2)"></td>
            </tr>
            <tr>
                <th></th>
                <th>XY plane</th>
                <th>XZ plane</th>
                <th>YZ plane</th>
            </tr>
            <tr>
                <td>Shear 2</td>
                <td><input id="shearXY2" type="range" autocomplete="off" value="0" max="1" min="-1" step="0.1" oninput="update_shear(2)"></td>
                <td><input id="shearXZ2" type="range" autocomplete="off" value="0" max="1" min="-1" step="0.1" oninput="update_shear(2)"></td>
                <td><input id="shearYZ2" type="range" autocomplete="off" value="0" max="1" min="-1" step="0.1" oninput="update_shear(2)"></td>
            </tr>
            <tr>
                <td>Scale 2</td>
                <td><input id="scale2" type="range" autocomplete="off" value="5.0" max="10.0" min="2.0" step="0.1" oninput="update_scale(2)"></td>
            </tr>
        </table>

        <br/>
        <br/>

        <span>Object3 (Right)</span>
        <table>
            <tr>
                <th></th>
                <th>X axis</th>
                <th>Y axis</th>
                <th>Z axis</th>
            </tr>
            <tr>
                <td>Trans. 3</td>
                <td><input id="transX3" type="range" autocomplete="off" value="0." max="10." min="-50." oninput="update_trans(3)"></td>
                <td><input id="transY3" type="range" autocomplete="off" value="0." max="15." min="-15." oninput="update_trans(3)"></td>
                <td><input id="transZ3" type="range" autocomplete="off" value="-50." max="-40." min="-100." oninput="update_trans(3)"></td>
            </tr>
            <tr>
                <td>Rotate 3</td>
                <td><input id="rotateX3" type="range" autocomplete="off" value="0." max="180." min="-180." oninput="update_rotate(3)"></td>
                <td><input id="rotateY3" type="range" autocomplete="off" value="0." max="180." min="-180." oninput="update_rotate(3)"></td>
                <td><input id="rotateZ3" type="range" autocomplete="off" value="0." max="180." min="-180." oninput="update_rotate(3)"></td>
            </tr>
            <tr>
                <th></th>
                <th>XY plane</th>
                <th>XZ plane</th>
                <th>YZ plane</th>
            </tr>
            <tr>
                <td>Shear 3</td>
                <td><input id="shearXY3" type="range" autocomplete="off" value="0" max="1" min="-1" step="0.1" oninput="update_shear(3)"></td>
                <td><input id="shearXZ3" type="range" autocomplete="off" value="0" max="1" min="-1" step="0.1" oninput="update_shear(3)"></td>
                <td><input id="shearYZ3" type="range" autocomplete="off" value="0" max="1" min="-1" step="0.1" oninput="update_shear(3)"></td>
            </tr>
            <tr>
                <th>(ax + by + cz + d = 0)</th>
            </tr>
            <tr>
                <td>Clip Plane 3</td>
                <td>a: <input id="clip3A" type="range" value="0.0" max="1.0" min="-1.0" step="0.1" oninput="updateClipPlane(3)"></td>
                <td>b: <input id="clip3B" type="range" value="0.0" max="1.0" min="-1.0" step="0.1" oninput="updateClipPlane(3)"></td>
                <td>c: <input id="clip3C" type="range" value="0.0" max="1.0" min="-1.0" step="0.1" oninput="updateClipPlane(3)"></td>
                <td>d: <input id="clip3D" type="range" value="0.0" max="50.0" min="-50.0" step="1.0" oninput="updateClipPlane(3)"></td>
            </tr>
            <tr>
                <td>Scale 3</td>
                <td><input id="scale3" type="range" autocomplete="off" value="6.0" max="12.0" min="2.0" step="0.1" oninput="update_scale(3)"></td>
            </tr>
        </table>
        </p>
    </body>

</html>
