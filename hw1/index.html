<html>

    <head>
        <title>ICG WebGL &mdash; HW1</title>
        <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

        <script type="text/javascript" src="./js/glMatrix-0.9.5.min.js"></script>
        <script type="text/javascript" src="./js/webgl-utils.js"></script>

        <!-- 
TODO HERE: 
modify fragment shader or write another one
to implement flat, gouraud and phong shading
-->     <script id="flatFragmentShader" type="fragment">
        #extension GL_OES_standard_derivatives : enable

        precision mediump float;

        varying vec4 fragcolor;

        void main(void) {
        gl_FragColor = fragcolor;
        }
        </script>

        <script id="gouraudFragmentShader" type="fragment">
        #extension GL_OES_standard_derivatives : enable

        precision mediump float;

        varying vec4 fragcolor;

        void main(void) {
        gl_FragColor = fragcolor;
        }
        </script>

        <script id="phongFragmentShader" type="fragment">
        precision mediump float;

        varying vec3 vPosition;
        varying vec3 vNormal;
        varying vec3 vColor;

        uniform float Ka;
        uniform vec3 lightLoc;

        void main(void) {
            vec3 lightColor = vec3(1.0, 1.0, 1.0);
            
            vec3 N = normalize(vNormal);
            vec3 L = normalize(lightLoc - vPosition);
            vec3 V = normalize(-vPosition);
            vec3 H = normalize(L + V);
            
            float ka = Ka;
            float kd = 0.6;
            float ks = 0.3;
            float shininess = 16.0;
            
            vec3 ambient = ka * vColor;
            float diff = max(dot(N, L), 0.0);
            vec3 diffuse = kd * diff * vColor;
            float spec = pow(max(dot(N, H), 0.0), shininess);
            vec3 specular = ks * spec * lightColor;
            
            gl_FragColor = vec4(ambient + diffuse + specular, 1.0);
        }
        </script>

        <!-- 
TODO HERE:
modify vertex shader or write another one
to implement flat, gouraud and phong shading

NOTE:
if you want to write bonus part (texture mapping),
only Teapot.json has extra attribute "vertexTextureCoords"
which is used for texture mappping.
-->
        <script id="flatVertexShader" type="vertex">
        attribute vec3 aVertexPosition;
        attribute vec3 aFrontColor;
        attribute vec3 aVertexNormal;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;

        // Ambient light coef.
        uniform float Ka;
        // light1 location (x,y,z)
        uniform vec3 lightLoc;

        varying vec4 fragcolor;

        void main(void) {
        vec3 lightColor = vec3(1.0, 1.0, 1.0);

        // Transform VertexPosition and VertexNormal to world coordinate system
        vec3 mvVertex = (uMVMatrix * vec4(aVertexPosition, 1.0)).xyz;
        mat3 normalMVMatrix = mat3(uMVMatrix);
        vec3 mvNormal = normalMVMatrix * aVertexNormal;

        // V, N, L, H
        vec3 V = -normalize(mvVertex);
        vec3 N = normalize(mvNormal);
        vec3 L = normalize(lightLoc - mvVertex);
        vec3 H = normalize(L + V);

        // Ambient, diffuse and specular coef.
        float ka = Ka;
        float kd = 0.6;
        float ks = 0.3;

        vec3 gouraud = vec3(0.5, 0.5, 0.5);

        // *TODO* 
        //  Finish the formula of ambient, diffuse and specular

        float shininess = 16.0;

        vec3 ambient = ka * aFrontColor;

        float diff = max(dot(N, L), 0.0);
        vec3 diffuse = kd * diff * aFrontColor;

        float spec = pow(max(dot(N, H), 0.0), shininess);
        vec3 specular = ks * spec * lightColor;

        gouraud = ambient + diffuse + specular;

        fragcolor = vec4(gouraud, 1.0);
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        }
        </script>

        <script id="gouraudVertexShader" type="vertex">
        attribute vec3 aVertexPosition;
        attribute vec3 aFrontColor;
        attribute vec3 aVertexNormal;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;

        // Ambient light coef.
        uniform float Ka;
        // light1 location (x,y,z)
        uniform vec3 lightLoc;

        varying vec4 fragcolor;

        void main(void) {
        vec3 lightColor = vec3(1.0, 1.0, 1.0);

        // Transform VertexPosition and VertexNormal to world coordinate system
        vec3 mvVertex = (uMVMatrix * vec4(aVertexPosition, 1.0)).xyz;
        mat3 normalMVMatrix = mat3(uMVMatrix);
        vec3 mvNormal = normalMVMatrix * aVertexNormal;

        // V, N, L, H
        vec3 V = -normalize(mvVertex);
        vec3 N = normalize(mvNormal);
        vec3 L = normalize(lightLoc - mvVertex);
        vec3 H = normalize(L + V);

        // Ambient, diffuse and specular coef.
        float ka = Ka;
        float kd = 0.6;
        float ks = 0.3;

        vec3 gouraud = vec3(0.5, 0.5, 0.5);

        // *TODO* 
        //  Finish the formula of ambient, diffuse and specular

        float shininess = 16.0;

        vec3 ambient = ka * aFrontColor;

        float diff = max(dot(N, L), 0.0);
        vec3 diffuse = kd * diff * aFrontColor;

        float spec = pow(max(dot(N, H), 0.0), shininess);
        vec3 specular = ks * spec * lightColor;

        gouraud = ambient + diffuse + specular;

        fragcolor = vec4(gouraud, 1.0);
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        }
        </script>

        <script id="phongVertexShader" type="vertex">
        attribute vec3 aVertexPosition;
        attribute vec3 aFrontColor;
        attribute vec3 aVertexNormal;

        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;

        varying vec3 vPosition;
        varying vec3 vNormal;
        varying vec3 vColor;

        void main(void) {
            vec4 mvPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
            vPosition = mvPosition.xyz;
            mat3 normalMatrix = mat3(uMVMatrix);
            vNormal = normalize(normalMatrix * aVertexNormal);
            vColor = aFrontColor;
            gl_Position = uPMatrix * mvPosition;
        }
        </script>

        <script type="text/javascript">
        // common variables
        var gl;
        var flatShaderProgram;
        var gouraudShaderProgram;
        var phongShaderProgram;

        var mvMatrix1 = mat4.create();
        var mvMatrix2 = mat4.create();
        var mvMatrix3 = mat4.create();
        var pMatrix1  = mat4.create();
        var pMatrix2  = mat4.create();
        var pMatrix3  = mat4.create();

        var teapotVertexPositionBuffer;
        var teapotVertexNormalBuffer;
        var teapotVertexFrontColorBuffer;

        var flatTeapotVertexPositionBuffer;
        var flatTeapotVertexNormalBuffer;
        var flatTeapotVertexFrontColorBuffer;

        var teapot1Angle = 180;
        var teapot2Angle = 180;
        var teapot3Angle = 180;
        var lastTime    = 0;

        var ka = 0.1;
        var light_locations = new Float32Array([30., 20., -25.]);


        //*************************************************
        // Initialization functions
        //*************************************************
        function initGL(canvas) {
            try {
                gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
                gl.viewportWidth  = canvas.width;
                gl.viewportHeight = canvas.height;
            } 
            catch (e) {
            }

            if (!gl) {
                alert("Could not initialise WebGL");
            }
        }

        function getShader(gl, id) {
            var shaderScript = document.getElementById(id);
            if (!shaderScript) {
                return null;
            }

            var shaderSource = "";
            var k = shaderScript.firstChild;
            while (k) {
                if (k.nodeType == 3) {
                    shaderSource += k.textContent;
                }

                k = k.nextSibling;
            }

            var shader;
            if (shaderScript.type == "fragment") {
                shader = gl.createShader(gl.FRAGMENT_SHADER);
            } 
            else if (shaderScript.type == "vertex") {
                shader = gl.createShader(gl.VERTEX_SHADER);
            } 
            else {
                return null;
            }

            gl.shaderSource(shader, shaderSource);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert(gl.getShaderInfoLog(shader));
                return null;
            }

            return shader;
        }

        function initShaders() {
            // Create flat shader program
            var flatFragmentShader = getShader(gl, "flatFragmentShader");
            var flatVertexShader   = getShader(gl, "flatVertexShader");
            flatShaderProgram = createShaderProgram(flatVertexShader, flatFragmentShader);

            var gouraudFragmentShader = getShader(gl, "gouraudFragmentShader");
            var gouraudVertexShader   = getShader(gl, "gouraudVertexShader");
            gouraudShaderProgram = createShaderProgram(gouraudVertexShader, gouraudFragmentShader);

            var phongFragmentShader = getShader(gl, "phongFragmentShader");
            var phongVertexShader = getShader(gl, "phongVertexShader");
            phongShaderProgram = createShaderProgram(phongVertexShader, phongFragmentShader);
        }

        function createShaderProgram(customVS, customFS) {
            var program = gl.createProgram();
            gl.attachShader(program, customVS);
            gl.attachShader(program, customFS);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }

            gl.useProgram(program);

            program.vertexPositionAttribute = gl.getAttribLocation(program, "aVertexPosition");
            gl.enableVertexAttribArray(program.vertexPositionAttribute);
            program.vertexFrontColorAttribute = gl.getAttribLocation(program, "aFrontColor");
            gl.enableVertexAttribArray(program.vertexFrontColorAttribute);
            program.vertexNormalAttribute = gl.getAttribLocation(program, "aVertexNormal");
            gl.enableVertexAttribArray(program.vertexNormalAttribute);

            gl.uniform1f(gl.getUniformLocation(program, "Ka"), ka);
            gl.uniform3fv(gl.getUniformLocation(program, "lightLoc"), light_locations);

            program.pMatrixUniform  = gl.getUniformLocation(program, "uPMatrix");
            program.mvMatrixUniform = gl.getUniformLocation(program, "uMVMatrix");

            return program;
        }

        function setMatrixUniforms(program, mvMatrix, pMatrix) {
            gl.uniformMatrix4fv(program.pMatrixUniform, false, pMatrix);
            gl.uniformMatrix4fv(program.mvMatrixUniform, false, mvMatrix);
        }

        function degToRad(degrees) {
            return degrees * Math.PI / 180;
        }

        function convertToFlatShading(teapotData) {
            const positions = teapotData.vertexPositions;
            const colors = teapotData.vertexFrontcolors;
            const flatPositions = [];
            const flatNormals = [];
            const flatColors = [];

            for (let i = 0; i < positions.length; i += 9) {
                // 一組 triangle：3 個頂點，每個 3 維
                const v0 = positions.slice(i, i + 3);
                const v1 = positions.slice(i + 3, i + 6);
                const v2 = positions.slice(i + 6, i + 9);

                const normal = computeFaceNormal(v0, v1, v2);

                // 使用第一個頂點的顏色當整個面的顏色
                const c0 = colors.slice(i, i + 3);

                [v0, v1, v2].forEach((v) => {
                    flatPositions.push(...v);
                    flatNormals.push(...normal);
                    flatColors.push(...c0);
                });
            }

            return {
                vertexPositions: flatPositions,
                vertexNormals: flatNormals,
                vertexFrontcolors: flatColors
            };
        }

        function computeFaceNormal(v0, v1, v2) {
            const U = [
                v1[0] - v0[0],
                v1[1] - v0[1],
                v1[2] - v0[2]
            ];
            const V = [
                v2[0] - v0[0],
                v2[1] - v0[1],
                v2[2] - v0[2]
            ];
            const N = [
                U[1] * V[2] - U[2] * V[1],
                U[2] * V[0] - U[0] * V[2],
                U[0] * V[1] - U[1] * V[0]
            ];
            const length = Math.sqrt(N[0] * N[0] + N[1] * N[1] + N[2] * N[2]);
            return [N[0] / length, N[1] / length, N[2] / length];
        }

        function handleLoadedTeapot(teapotData) {
            var vertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(teapotData.vertexPositions), gl.STATIC_DRAW);
            vertexPositionBuffer.itemSize = 3;
            vertexPositionBuffer.numItems = teapotData.vertexPositions.length / 3;

            var vertexNormalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(teapotData.vertexNormals), gl.STATIC_DRAW);
            vertexNormalBuffer.itemSize = 3;
            vertexNormalBuffer.numItems = teapotData.vertexNormals.length / 3;

            var vertexFrontColorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexFrontColorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(teapotData.vertexFrontcolors), gl.STATIC_DRAW);
            vertexFrontColorBuffer.itemSize = 3;
            vertexFrontColorBuffer.numItems = teapotData.vertexFrontcolors.length / 3;

            return {
                positionBuffer: vertexPositionBuffer,
                normalBuffer: vertexNormalBuffer,
                colorBuffer: vertexFrontColorBuffer
            };
        }

        function loadTeapot() {
            var request = new XMLHttpRequest();
            request.open("GET", "./model/Teapot.json");
            request.onreadystatechange = function () {
                if (request.readyState == 4) {
                    let teapotData = JSON.parse(request.responseText);
                    let buffers = handleLoadedTeapot(teapotData);
                    teapotVertexPositionBuffer = buffers.positionBuffer;
                    teapotVertexNormalBuffer = buffers.normalBuffer;
                    teapotVertexFrontColorBuffer = buffers.colorBuffer;
                    console.log("teapotData: " + teapotVertexNormalBuffer);

                    let flatTeapotData = convertToFlatShading(teapotData);
                    let flatBuffers = handleLoadedTeapot(flatTeapotData);
                    flatTeapotVertexPositionBuffer = flatBuffers.positionBuffer;
                    flatTeapotVertexNormalBuffer = flatBuffers.normalBuffer;
                    flatTeapotVertexFrontColorBuffer = flatBuffers.colorBuffer;
                    console.log("flatTeapotData: " + flatTeapotVertexNormalBuffer);
                }
            }
            request.send();
        }

        //*************************************************
        // Rendering functions
        //*************************************************
        /*
        TODO HERE:
        add two or more objects showing on the canvas
        (it needs at least three objects showing at the same time)
    */

        function drawAllScene() {
            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
            gl.clearColor(ka, ka, ka, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            drawScene(mvMatrix1, pMatrix1, -20, 0, 0, teapot1Angle, flatShaderProgram, true);
            drawScene(mvMatrix2, pMatrix2, 0, 0, 0, teapot2Angle, gouraudShaderProgram, false);
            drawScene(mvMatrix3, pMatrix3, 20, 0, 0, teapot3Angle, phongShaderProgram, false);
        }

        function drawScene(mvMatrix, pMatrix, translate_x, translate_y, translate_z, angle, program, isFlat) {
            gl.useProgram(program);

            var vertexPositionBuffer;
            var vertexNormalBuffer;
            var vertexFrontColorBuffer;

            if (isFlat) {
                vertexPositionBuffer = flatTeapotVertexPositionBuffer;
                vertexNormalBuffer = flatTeapotVertexNormalBuffer;
                vertexFrontColorBuffer = flatTeapotVertexFrontColorBuffer;
            } else {
                vertexPositionBuffer = teapotVertexPositionBuffer;
                vertexNormalBuffer = teapotVertexNormalBuffer;
                vertexFrontColorBuffer = teapotVertexFrontColorBuffer;
            }

            if (vertexPositionBuffer   == null || 
                vertexNormalBuffer     == null || 
                vertexFrontColorBuffer == null) {
                return;
            }

            // Setup Projection Matrix
            mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

            // Setup Model-View Matrix
            mat4.identity(mvMatrix);
            mat4.translate(mvMatrix, [translate_x, translate_y, translate_z]);
            mat4.translate(mvMatrix, update_trans());

            var rotateVec_init = [0,0,0];
            mat4.rotate(mvMatrix, degToRad(rotateVec_init[0]), [1, 0, 0]);
            mat4.rotate(mvMatrix, degToRad(rotateVec_init[1]), [0, 1, 0]);
            mat4.rotate(mvMatrix, degToRad(rotateVec_init[2]), [0, 0, 1]);

            var rotateVec = update_rotate();
            mat4.rotate(mvMatrix, degToRad(rotateVec[0]), [1, 0, 0]);
            mat4.rotate(mvMatrix, degToRad(rotateVec[1] + angle), [0, 1, 0]);
            mat4.rotate(mvMatrix, degToRad(rotateVec[2]), [0, 0, 1]);
            mat4.scale(mvMatrix, [0.5, 0.5, 0.5]);

            setMatrixUniforms(program, mvMatrix, pMatrix);

            // Setup teapot position data
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
            gl.vertexAttribPointer(program.vertexPositionAttribute, 
                vertexPositionBuffer.itemSize, 
                gl.FLOAT, 
                false, 
                0, 
                0);

            // Setup teapot front color data
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexFrontColorBuffer);
            gl.vertexAttribPointer(program.vertexFrontColorAttribute, 
                vertexFrontColorBuffer.itemSize, 
                gl.FLOAT, 
                false, 
                0, 
                0);

            // Setup teapot normal data
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);
            gl.vertexAttribPointer(program.vertexNormalAttribute, 
                vertexNormalBuffer.itemSize, 
                gl.FLOAT, 
                false, 
                0, 
                0);

            // Setup ambient light and light position
            gl.uniform1f(gl.getUniformLocation(program, "Ka"), ka);
            gl.uniform3fv(gl.getUniformLocation(program, "lightLoc"), light_locations);

            gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems);
        }

        function animate() {
            var timeNow = new Date().getTime();
            if (lastTime != 0) {
                var elapsed = timeNow - lastTime;
                teapot1Angle += 0.03 * elapsed;
                teapot2Angle += 0.03 * elapsed;
                teapot3Angle += 0.03 * elapsed;
            }

            lastTime = timeNow;
        }

        function tick() {
            requestAnimFrame(tick);
            drawAllScene();
            animate();
        }

        function webGLStart() {
            var canvas = document.getElementById("ICG-canvas");
            initGL(canvas);
            initShaders();
            loadTeapot();

            gl.clearColor(ka, ka, ka, 1.0);
            gl.enable(gl.DEPTH_TEST);

            tick();
        }


        //*************************************************
        // Parsing parameters
        //*************************************************
        function update_ambient_light(){
            ka = document.getElementById("am_ka").value;
        }

        function update_light_location(){
            light_locations[0] = document.getElementById("llocX").value;
            light_locations[1] = document.getElementById("llocY").value;
            light_locations[2] = document.getElementById("llocZ").value;
        }

        function update_trans(){
            var tx = document.getElementById("transX").value;
            var ty = document.getElementById("transY").value;
            var tz = document.getElementById("transZ").value;

            return vec3.create([tx, ty, tz]);
        }

        function update_rotate(){
            var rx = document.getElementById("rotateX").value;
            var ry = document.getElementById("rotateY").value;
            var rz = document.getElementById("rotateZ").value;

            return vec3.create([rx, ry, rz]);
        }

        </script>
    </head>

    <body onload="webGLStart();">
        <p style="position: absolute; right: 2%; top:6%; ">
            <canvas id="ICG-canvas" style="border: none;" width="1060" height="590" ></canvas>
        </p>

        <p style="position: absolute; left: 1%; top: 1%; max-width: 30%; min-width: 30%; ">

        <p>
            <label for="shading">Gouraud shading</label>
        </p>

        <br/>
        <span>Ambient Light</span>
        <table>
            <tr>
                <td>Ka: <input style="max-width: 70%; vertical-align: middle;" id="am_ka" type="range" autocomplete="off" value="0.1" max="1." min="0." step="0.05" oninput="update_ambient_light()"></td>
            </tr>
        </table>
        <br/>
        <span>Light 0</span>
        <table>
            <tr>
                <td>X: <input style="max-width: 70%; vertical-align: middle;" id="llocX" type="range" autocomplete="off" value="30." max="40." min="-40." oninput="update_light_location()"></td>
                <td>Y: <input style="max-width: 70%; vertical-align: middle;" id="llocY" type="range" autocomplete="off" value="20." max="40." min="-40." oninput="update_light_location()"></td>
                <td>Z: <input style="max-width: 70%; vertical-align: middle;" id="llocZ" type="range" autocomplete="off" value="-25." max="0." min="-75." oninput="update_light_location()"></td>
            </tr>
        </table>
        <br/>
        <br/>
        <br/>

        <span>Object</span>
        <table>
            <tr>
                <th></th>
                <th>X axis</th>
                <th>Y axis</th>
                <th>Z axis</th>
            </tr>
            <tr>
                <td>Trans.</td>
                <td><input id="transX" type="range" autocomplete="off" value="0." max="50." min="-50." oninput="update_trans()"></td>
                <td><input id="transY" type="range" autocomplete="off" value="0." max="50." min="-50." oninput="update_trans()"></td>
                <td><input id="transZ" type="range" autocomplete="off" value="-50." max="0." min="-120." oninput="update_trans()"></td>
            </tr>
            <tr>
                <td>Rotate</td>
                <td><input id="rotateX" type="range" autocomplete="off" value="0." max="180." min="-180." oninput="update_rotate()"></td>
                <td><input id="rotateY" type="range" autocomplete="off" value="0." max="180." min="-180." oninput="update_rotate()"></td>
                <td><input id="rotateZ" type="range" autocomplete="off" value="0." max="180." min="-180." oninput="update_rotate()"></td>
            </tr>
        </table>
        </p>

    </body>

</html>
